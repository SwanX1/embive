//! # Embive (Embedded RISC-V)
//!
//! Embive is a low-level sandboxing library focused on the embedding of untrusted code for constrained environments.  
//! As it interprets RISC-V bytecode, multiple languages are supported out of the box by Embive (Rust, C, C++, Zig, TinyGo, etc.).  
//! By default, it doesnâ€™t require external crates, dynamic memory allocation or the standard library (`no_std` & `no_alloc`).
//!
//! Currently, it supports the `RV32I[M]` unprivileged instruction set (M extension enabled by default, check [Features](#features)).
//!
//! ## Bytecode
//! The bytecode can be generated by any compiler that supports the RV32I\[M\] instruction set, as long as it can output a flat binary file
//! (`.bin`) statically linked to the correct addresses (Code at `0x00000000`, RAM at [`crate::memory::RAM_OFFSET`]).
//!
//! ## Example
//!
//! ```no_run
//! use embive::{engine::{Engine, Config, SYSCALL_ARGS}, memory::Memory, register::Register};
//!
//! // A simple syscall example. Check [`engine::SyscallFn`] for more information.
//! fn syscall(nr: i32, args: &[i32; SYSCALL_ARGS], memory: &mut Memory) -> Result<i32, i32> {
//!     println!("{}: {:?}", nr, args);
//!     match nr {
//!         1 => Ok(args[0] + args[1]), // Add two numbers (arg[0] + arg[1])
//!         2 => match memory.load(args[0] as u32) { // Load from RAM (arg[0])
//!             Ok(val) => Ok(i32::from_le_bytes(val)), // RISC-V is little endian
//!             Err(_) => Err(1),
//!         },
//!         _ => Err(2),
//!     }
//! }
//!
//! fn main() {
//!     // "10 + 20" using syscalls (load from ram and add two numbers)
//!     let code = &[
//!         0x93, 0x08, 0x20, 0x00, // li   a7, 2      (Syscall nr)
//!         0x13, 0x05, 0x10, 0x00, // li   a0, 1      (arg0, set first bit)
//!         0x13, 0x15, 0xf5, 0x01, // slli a0, a0, 31 (arg0, shift-left 31 bits)
//!         0x73, 0x00, 0x00, 0x00, // ecall           (Syscall, load from arg0)
//!         0x93, 0x08, 0x10, 0x00, // li   a7, 1      (Syscall nr)
//!         0x93, 0x05, 0x40, 0x01, // li   a1,20      (arg1, 20)
//!         0x73, 0x00, 0x00, 0x00, // ecall           (Syscall, add two args)
//!         0x73, 0x00, 0x10, 0x00  // ebreak          (Halt)
//!     ];
//!     let mut ram = [0; 1024];
//!     ram[..4].copy_from_slice(&u32::to_le_bytes(10));
//!
//!     // Create engine config
//!     let config = Config {
//!         syscall_fn: Some(syscall),
//!         ..Default::default()
//!    };
//!
//!     // Create engine
//!     let mut engine = Engine::new(code, &mut ram, config).unwrap();
//!
//!     // Run it
//!     engine.run().unwrap();
//!
//!     // Check the result
//!    assert_eq!(engine.registers().get(Register::A0 as usize).unwrap(), 30);
//!    assert_eq!(engine.registers().get(Register::A1 as usize).unwrap(), 0);
//! }
//! ```
//!
//! ## Features
//! Without any feature enabled, this crates has no external dependencies and can be used in a `no_std` & `no_alloc` environment.
//! Check the available features and their descriptions below:
//!
//! - `m_extension`:
//!     - Enable the RV32M extension (multiply and divide instructions).
//!         - Enabled by default, no additional dependencies.
//! - `instruction_limit`:
//!     - Limit the number of instructions executed by the engine, yielding when the limit is reached.
//!         - Disabled by default, no additional dependencies.
#![cfg_attr(not(test), no_std)]
pub mod engine;
pub mod error;
mod instruction;
pub mod memory;
pub mod register;
